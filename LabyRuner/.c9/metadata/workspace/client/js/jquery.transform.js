{"filter":false,"title":"jquery.transform.js","tooltip":"/client/js/jquery.transform.js","ace":{"folds":[],"scrolltop":7432,"scrollleft":0,"selection":{"start":{"row":558,"column":0},"end":{"row":558,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":90,"state":"doc-start","mode":"ace/mode/javascript"}},"hash":"d2f2e79d740e5e2cc88936acd4d4fbe68df2271f","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":558,"column":0},"action":"insert","lines":["/*!"," * jQuery 2d Transform v@VERSION"," * http://wiki.github.com/heygrady/transform/"," *"," * Copyright 2010, Grady Kuhnline"," * Dual licensed under the MIT or GPL Version 2 licenses."," * http://jquery.org/license"," * "," * Date: "," */","///////////////////////////////////////////////////////","// Transform","///////////////////////////////////////////////////////","(function($, window, document, undefined) {","\t/**","\t * @var Regex identify the matrix filter in IE","\t */","\tvar rmatrix = /progid:DXImageTransform\\.Microsoft\\.Matrix\\(.*?\\)/,","\t\trfxnum = /^([\\+\\-]=)?([\\d+.\\-]+)(.*)$/,","\t\trperc = /%/;","\t","\t// Steal some code from Modernizr","\tvar m = document.createElement( 'modernizr' ),","\t\tm_style = m.style;","\t\t","\tfunction stripUnits(arg) {","\t\treturn parseFloat(arg);","\t}","\t","\t/**","\t * Find the prefix that this browser uses","\t */\t","\tfunction getVendorPrefix() {","\t\tvar property = {","\t\t\ttransformProperty : '',","\t\t\tMozTransform : '-moz-',","\t\t\tWebkitTransform : '-webkit-',","\t\t\tOTransform : '-o-',","\t\t\tmsTransform : '-ms-'","\t\t};","\t\tfor (var p in property) {","\t\t\tif (typeof m_style[p] != 'undefined') {","\t\t\t\treturn property[p];","\t\t\t}","\t\t}","\t\treturn null;","\t}","\t","\tfunction supportCssTransforms() {","\t\tif (typeof(window.Modernizr) !== 'undefined') {","\t\t\treturn Modernizr.csstransforms;","\t\t}","\t\t","\t\tvar props = [ 'transformProperty', 'WebkitTransform', 'MozTransform', 'OTransform', 'msTransform' ];","\t\tfor ( var i in props ) {","\t\t\tif ( m_style[ props[i] ] !== undefined  ) {","\t\t\t\treturn true;","\t\t\t}","\t\t}","\t}","\t\t","\t// Capture some basic properties","\tvar vendorPrefix\t\t\t= getVendorPrefix(),","\t\ttransformProperty\t\t= vendorPrefix !== null ? vendorPrefix + 'transform' : false,","\t\ttransformOriginProperty\t= vendorPrefix !== null ? vendorPrefix + 'transform-origin' : false;","\t","\t// store support in the jQuery Support object","\t$.support.csstransforms = supportCssTransforms();","\t","\t// IE9 public preview 6 requires the DOM names","\tif (vendorPrefix == '-ms-') {","\t\ttransformProperty = 'msTransform';","\t\ttransformOriginProperty = 'msTransformOrigin';","\t}","\t","\t/**","\t * Class for creating cross-browser transformations","\t * @constructor","\t */","\t$.extend({","\t\ttransform: function(elem) {","\t\t\t// Cache the transform object on the element itself","\t\t\telem.transform = this;","\t\t\t","\t\t\t/**","\t\t\t * The element we're working with","\t\t\t * @var jQueryCollection","\t\t\t */","\t\t\tthis.$elem = $(elem);","\t\t\t\t\t\t","\t\t\t/**","\t\t\t * Remember the matrix we're applying to help the safeOuterLength func","\t\t\t */","\t\t\tthis.applyingMatrix = false;","\t\t\tthis.matrix = null;","\t\t\t","\t\t\t/**","\t\t\t * Remember the css height and width to save time","\t\t\t * This is only really used in IE","\t\t\t * @var Number","\t\t\t */","\t\t\tthis.height = null;","\t\t\tthis.width = null;","\t\t\tthis.outerHeight = null;","\t\t\tthis.outerWidth = null;","\t\t\t","\t\t\t/**","\t\t\t * We need to know the box-sizing in IE for building the outerHeight and outerWidth","\t\t\t * @var string","\t\t\t */","\t\t\tthis.boxSizingValue = null;","\t\t\tthis.boxSizingProperty = null;","\t\t\t","\t\t\tthis.attr = null;","\t\t\tthis.transformProperty = transformProperty;","\t\t\tthis.transformOriginProperty = transformOriginProperty;","\t\t}","\t});","\t","\t$.extend($.transform, {","\t\t/**","\t\t * @var Array list of all valid transform functions","\t\t */","\t\tfuncs: ['matrix', 'origin', 'reflect', 'reflectX', 'reflectXY', 'reflectY', 'rotate', 'scale', 'scaleX', 'scaleY', 'skew', 'skewX', 'skewY', 'translate', 'translateX', 'translateY']","\t});","\t","\t/**","\t * Create Transform as a jQuery plugin","\t * @param Object funcs","\t * @param Object options","\t */","\t$.fn.transform = function(funcs, options) {","\t\treturn this.each(function() {","\t\t\tvar t = this.transform || new $.transform(this);","\t\t\tif (funcs) {","\t\t\t\tt.exec(funcs, options);","\t\t\t}","\t\t});","\t};","\t","\t$.transform.prototype = {","\t\t/**","\t\t * Applies all of the transformations","\t\t * @param Object funcs","\t\t * @param Object options","\t\t * forceMatrix - uses the matrix in all browsers","\t\t * preserve - tries to preserve the values from previous runs","\t\t */","\t\texec: function(funcs, options) {","\t\t\t// extend options","\t\t\toptions = $.extend(true, {","\t\t\t\tforceMatrix: false,","\t\t\t\tpreserve: false","\t\t\t}, options);","\t","\t\t\t// preserve the funcs from the previous run","\t\t\tthis.attr = null;","\t\t\tif (options.preserve) {","\t\t\t\tfuncs = $.extend(true, this.getAttrs(true, true), funcs);","\t\t\t} else {","\t\t\t\tfuncs = $.extend(true, {}, funcs); // copy the object to prevent weirdness","\t\t\t}","\t\t\t","\t\t\t// Record the custom attributes on the element itself","\t\t\tthis.setAttrs(funcs);","\t\t\t","\t\t\t// apply the funcs","\t\t\tif ($.support.csstransforms && !options.forceMatrix) {","\t\t\t\t// CSS3 is supported","\t\t\t\treturn this.execFuncs(funcs);","\t\t\t} else if ($.browser.msie || ($.support.csstransforms && options.forceMatrix)) {","\t\t\t\t// Internet Explorer or Forced matrix","\t\t\t\treturn this.execMatrix(funcs);","\t\t\t}","\t\t\treturn false;","\t\t},","\t\t","\t\t/**","\t\t * Applies all of the transformations as functions","\t\t * @param Object funcs","\t\t */","\t\texecFuncs: function(funcs) {","\t\t\tvar values = [];","\t\t\t","\t\t\t// construct a CSS string","\t\t\tfor (var func in funcs) {","\t\t\t\t// handle origin separately","\t\t\t\tif (func == 'origin') {","\t\t\t\t\tthis[func].apply(this, $.isArray(funcs[func]) ? funcs[func] : [funcs[func]]);","\t\t\t\t} else if ($.inArray(func, $.transform.funcs) !== -1) {","\t\t\t\t\tvalues.push(this.createTransformFunc(func, funcs[func]));","\t\t\t\t}","\t\t\t}","\t\t\tthis.$elem.css(transformProperty, values.join(' '));","\t\t\treturn true;","\t\t},","\t\t","\t\t/**","\t\t * Applies all of the transformations as a matrix","\t\t * @param Object funcs","\t\t */","\t\texecMatrix: function(funcs) {","\t\t\tvar matrix,","\t\t\t\ttempMatrix,","\t\t\t\targs;","\t\t\t","\t\t\tvar elem = this.$elem[0],","\t\t\t\t_this = this;","\t\t\tfunction normalPixels(val, i) {","\t\t\t\tif (rperc.test(val)) {","\t\t\t\t\t// this really only applies to translation","\t\t\t\t\treturn parseFloat(val) / 100 * _this['safeOuter' + (i ? 'Height' : 'Width')]();","\t\t\t\t}","\t\t\t\treturn toPx(elem, val);","\t\t\t}","\t\t\t","\t\t\tvar rtranslate = /translate[X|Y]?/,","\t\t\t\ttrans = [];","\t\t\t\t","\t\t\tfor (var func in funcs) {","\t\t\t\tswitch ($.type(funcs[func])) {","\t\t\t\t\tcase 'array': args = funcs[func]; break;","\t\t\t\t\tcase 'string': args = $.map(funcs[func].split(','), $.trim); break;","\t\t\t\t\tdefault: args = [funcs[func]];","\t\t\t\t}","\t\t\t\t","\t\t\t\tif ($.matrix[func]) {","\t\t\t\t\t","\t\t\t\t\tif ($.cssAngle[func]) {","\t\t\t\t\t\t// normalize on degrees","\t\t\t\t\t\targs = $.map(args, $.angle.toDegree);\t\t\t\t\t\t","\t\t\t\t\t} else if (!$.cssNumber[func]) {","\t\t\t\t\t\t// normalize to pixels","\t\t\t\t\t\targs = $.map(args, normalPixels);","\t\t\t\t\t} else {","\t\t\t\t\t\t// strip units","\t\t\t\t\t\targs = $.map(args, stripUnits);","\t\t\t\t\t}","\t\t\t\t\t","\t\t\t\t\ttempMatrix = $.matrix[func].apply(this, args);","\t\t\t\t\tif (rtranslate.test(func)) {","\t\t\t\t\t\t//defer translation","\t\t\t\t\t\ttrans.push(tempMatrix);","\t\t\t\t\t} else {","\t\t\t\t\t\tmatrix = matrix ? matrix.x(tempMatrix) : tempMatrix;","\t\t\t\t\t}","\t\t\t\t} else if (func == 'origin') {","\t\t\t\t\tthis[func].apply(this, args);","\t\t\t\t}","\t\t\t}","\t\t\t","\t\t\t// check that we have a matrix","\t\t\tmatrix = matrix || $.matrix.identity();","\t\t\t","\t\t\t// Apply translation","\t\t\t$.each(trans, function(i, val) { matrix = matrix.x(val); });","","\t\t\t// pull out the relevant values","\t\t\tvar a = parseFloat(matrix.e(1,1).toFixed(6)),","\t\t\t\tb = parseFloat(matrix.e(2,1).toFixed(6)),","\t\t\t\tc = parseFloat(matrix.e(1,2).toFixed(6)),","\t\t\t\td = parseFloat(matrix.e(2,2).toFixed(6)),","\t\t\t\ttx = matrix.rows === 3 ? parseFloat(matrix.e(1,3).toFixed(6)) : 0,","\t\t\t\tty = matrix.rows === 3 ? parseFloat(matrix.e(2,3).toFixed(6)) : 0;","\t\t\t","\t\t\t//apply the transform to the element","\t\t\tif ($.support.csstransforms && vendorPrefix === '-moz-') {","\t\t\t\t// -moz-","\t\t\t\tthis.$elem.css(transformProperty, 'matrix(' + a + ', ' + b + ', ' + c + ', ' + d + ', ' + tx + 'px, ' + ty + 'px)');","\t\t\t} else if ($.support.csstransforms) {","\t\t\t\t// -webkit, -o-, w3c","\t\t\t\t// NOTE: WebKit and Opera don't allow units on the translate variables","\t\t\t\tthis.$elem.css(transformProperty, 'matrix(' + a + ', ' + b + ', ' + c + ', ' + d + ', ' + tx + ', ' + ty + ')');","\t\t\t} else if ($.browser.msie) {","\t\t\t\t// IE requires the special transform Filter","\t\t\t\t","\t\t\t\t//TODO: Use Nearest Neighbor during animation FilterType=\\'nearest neighbor\\'","\t\t\t\tvar filterType = ', FilterType=\\'nearest neighbor\\''; //bilinear","\t\t\t\tvar style = this.$elem[0].style;","\t\t\t\tvar matrixFilter = 'progid:DXImageTransform.Microsoft.Matrix(' +","\t\t\t\t\t\t'M11=' + a + ', M12=' + c + ', M21=' + b + ', M22=' + d +","\t\t\t\t\t\t', sizingMethod=\\'auto expand\\'' + filterType + ')';","\t\t\t\tvar filter = style.filter || $.curCSS( this.$elem[0], \"filter\" ) || \"\";","\t\t\t\tstyle.filter = rmatrix.test(filter) ? filter.replace(rmatrix, matrixFilter) : filter ? filter + ' ' + matrixFilter : matrixFilter;","\t\t\t\t","\t\t\t\t// Let's know that we're applying post matrix fixes and the height/width will be static for a bit","\t\t\t\tthis.applyingMatrix = true;","\t\t\t\tthis.matrix = matrix;","\t\t\t\t","\t\t\t\t// IE can't set the origin or translate directly","\t\t\t\tthis.fixPosition(matrix, tx, ty);","\t\t\t\t","\t\t\t\tthis.applyingMatrix = false;","\t\t\t\tthis.matrix = null;","\t\t\t}","\t\t\treturn true;","\t\t},","\t\t","\t\t/**","\t\t * Sets the transform-origin","\t\t * This really needs to be percentages","\t\t * @param Number x length","\t\t * @param Number y length","\t\t */","\t\torigin: function(x, y) {","\t\t\t// use CSS in supported browsers","\t\t\tif ($.support.csstransforms) {","\t\t\t\tif (typeof y === 'undefined') {","\t\t\t\t\tthis.$elem.css(transformOriginProperty, x);","\t\t\t\t} else {","\t\t\t\t\tthis.$elem.css(transformOriginProperty, x + ' ' + y);","\t\t\t\t}","\t\t\t\treturn true;","\t\t\t}","\t\t\t","\t\t\t// correct for keyword lengths","\t\t\tswitch (x) {","\t\t\t\tcase 'left': x = '0'; break;","\t\t\t\tcase 'right': x = '100%'; break;","\t\t\t\tcase 'center': // no break","\t\t\t\tcase undefined: x = '50%';","\t\t\t}","\t\t\tswitch (y) {","\t\t\t\tcase 'top': y = '0'; break;","\t\t\t\tcase 'bottom': y = '100%'; break;","\t\t\t\tcase 'center': // no break","\t\t\t\tcase undefined: y = '50%'; //TODO: does this work?","\t\t\t}","\t\t\t","\t\t\t// store mixed values with units, assumed pixels","\t\t\tthis.setAttr('origin', [","\t\t\t\trperc.test(x) ? x : toPx(this.$elem[0], x) + 'px',","\t\t\t\trperc.test(y) ? y : toPx(this.$elem[0], y) + 'px'","\t\t\t]);","\t\t\t//console.log(this.getAttr('origin'));","\t\t\treturn true;","\t\t},","\t\t","\t\t/**","\t\t * Create a function suitable for a CSS value","\t\t * @param string func","\t\t * @param Mixed value","\t\t */","\t\tcreateTransformFunc: function(func, value) {","\t\t\tif (func.substr(0, 7) === 'reflect') {","\t\t\t\t// let's fake reflection, false value ","\t\t\t\t// falsey sets an identity matrix","\t\t\t\tvar m = value ? $.matrix[func]() : $.matrix.identity();","\t\t\t\treturn 'matrix(' + m.e(1,1) + ', ' + m.e(2,1) + ', ' + m.e(1,2) + ', ' + m.e(2,2) + ', 0, 0)';","\t\t\t}","\t\t\t","\t\t\t//value = _correctUnits(func, value);","\t\t\t","\t\t\tif (func == 'matrix') {","\t\t\t\tif (vendorPrefix === '-moz-') {","\t\t\t\t\tvalue[4] = value[4] ? value[4] + 'px' : 0;","\t\t\t\t\tvalue[5] = value[5] ? value[5] + 'px' : 0;","\t\t\t\t}","\t\t\t}","\t\t\treturn func + '(' + ($.isArray(value) ? value.join(', ') : value) + ')';","\t\t},","\t\t","\t\t/**","\t\t * @param Matrix matrix","\t\t * @param Number tx","\t\t * @param Number ty","\t\t * @param Number height","\t\t * @param Number width","\t\t */","\t\tfixPosition: function(matrix, tx, ty, height, width) {","\t\t\t// now we need to fix it!","\t\t\tvar\tcalc = new $.matrix.calc(matrix, this.safeOuterHeight(), this.safeOuterWidth()),","\t\t\t\torigin = this.getAttr('origin'); // mixed percentages and px","\t\t\t","\t\t\t// translate a 0, 0 origin to the current origin","\t\t\tvar offset = calc.originOffset(new $.matrix.V2(","\t\t\t\trperc.test(origin[0]) ? parseFloat(origin[0])/100*calc.outerWidth : parseFloat(origin[0]),","\t\t\t\trperc.test(origin[1]) ? parseFloat(origin[1])/100*calc.outerHeight : parseFloat(origin[1])","\t\t\t));","\t\t\t","\t\t\t// IE glues the top-most and left-most pixels of the transformed object to top/left of the original object","\t\t\t//TODO: This seems wrong in the calculations","\t\t\tvar sides = calc.sides();","","\t\t\t// Protect against an item that is already positioned","\t\t\tvar cssPosition = this.$elem.css('position');","\t\t\tif (cssPosition == 'static') {","\t\t\t\tcssPosition = 'relative';","\t\t\t}","\t\t\t","\t\t\t//TODO: if the element is already positioned, we should attempt to respect it (somehow)","\t\t\t//NOTE: we could preserve our offset top and left in an attr on the elem","\t\t\tvar pos = {top: 0, left: 0};","\t\t\t","\t\t\t// Approximates transform-origin, tx, and ty","\t\t\tvar css = {","\t\t\t\t'position': cssPosition,","\t\t\t\t'top': (offset.top + ty + sides.top + pos.top) + 'px',","\t\t\t\t'left': (offset.left + tx + sides.left + pos.left) + 'px',","\t\t\t\t'zoom': 1","\t\t\t};","","\t\t\tthis.$elem.css(css);","\t\t}","\t};","\t","\t/**","\t * Ensure that values have the appropriate units on them","\t * @param string func","\t * @param Mixed value","\t */","\tfunction toPx(elem, val) {","\t\tvar parts = rfxnum.exec($.trim(val));","\t\t","\t\tif (parts[3] && parts[3] !== 'px') {","\t\t\tvar prop = 'paddingBottom',","\t\t\t\torig = $.style( elem, prop );","\t\t\t\t","\t\t\t$.style( elem, prop, val );","\t\t\tval = cur( elem, prop );","\t\t\t$.style( elem, prop, orig );","\t\t\treturn val;","\t\t}","\t\treturn parseFloat( val );","\t}","\t","\tfunction cur(elem, prop) {","\t\tif ( elem[prop] != null && (!elem.style || elem.style[prop] == null) ) {","\t\t\treturn elem[ prop ];","\t\t}","","\t\tvar r = parseFloat( $.css( elem, prop ) );","\t\treturn r && r > -10000 ? r : 0;","\t}","})(jQuery, this, this.document);","","","///////////////////////////////////////////////////////","// Safe Outer Length","///////////////////////////////////////////////////////","(function($, window, document, undefined) {","\t$.extend($.transform.prototype, {","\t\t/**","\t\t * @param void","\t\t * @return Number","\t\t */","\t\tsafeOuterHeight: function() {","\t\t\treturn this.safeOuterLength('height');","\t\t},","\t\t","\t\t/**","\t\t * @param void","\t\t * @return Number","\t\t */","\t\tsafeOuterWidth: function() {","\t\t\treturn this.safeOuterLength('width');","\t\t},","\t\t","\t\t/**","\t\t * Returns reliable outer dimensions for an object that may have been transformed.","\t\t * Only use this if the matrix isn't handy","\t\t * @param String dim height or width","\t\t * @return Number","\t\t */","\t\tsafeOuterLength: function(dim) {","\t\t\tvar funcName = 'outer' + (dim == 'width' ? 'Width' : 'Height');","\t\t\t","\t\t\tif (!$.support.csstransforms && $.browser.msie) {","\t\t\t\t// make the variables more generic","\t\t\t\tdim = dim == 'width' ? 'width' : 'height';","\t\t\t\t","\t\t\t\t// if we're transforming and have a matrix; we can shortcut.","\t\t\t\t// the true outerHeight is the transformed outerHeight divided by the ratio.","\t\t\t\t// the ratio is equal to the height of a 1px by 1px box that has been transformed by the same matrix.","\t\t\t\tif (this.applyingMatrix && !this[funcName] && this.matrix) {","\t\t\t\t\t// calculate and return the correct size","\t\t\t\t\tvar calc = new $.matrix.calc(this.matrix, 1, 1),","\t\t\t\t\t\tratio = calc.offset(),","\t\t\t\t\t\tlength = this.$elem[funcName]() / ratio[dim];","\t\t\t\t\tthis[funcName] = length;","\t\t\t\t\t","\t\t\t\t\treturn length;","\t\t\t\t} else if (this.applyingMatrix && this[funcName]) {","\t\t\t\t\t// return the cached calculation","\t\t\t\t\treturn this[funcName];","\t\t\t\t}","\t\t\t\t","\t\t\t\t// map dimensions to box sides\t\t\t","\t\t\t\tvar side = {","\t\t\t\t\theight: ['top', 'bottom'],","\t\t\t\t\twidth: ['left', 'right']","\t\t\t\t};","\t\t\t\t","\t\t\t\t// setup some variables","\t\t\t\tvar elem = this.$elem[0],","\t\t\t\t\touterLen = parseFloat($.curCSS(elem, dim, true)), //TODO: this can be cached on animations that do not animate height/width","\t\t\t\t\tboxSizingProp = this.boxSizingProperty,","\t\t\t\t\tboxSizingValue = this.boxSizingValue;","\t\t\t\t","\t\t\t\t// IE6 && IE7 will never have a box-sizing property, so fake it","\t\t\t\tif (!this.boxSizingProperty) {","\t\t\t\t\tboxSizingProp = this.boxSizingProperty = _findBoxSizingProperty() || 'box-sizing';","\t\t\t\t\tboxSizingValue = this.boxSizingValue = this.$elem.css(boxSizingProp) || 'content-box';","\t\t\t\t}","\t\t\t\t","\t\t\t\t// return it immediately if we already know it","\t\t\t\tif (this[funcName] && this[dim] == outerLen) {","\t\t\t\t\treturn this[funcName];","\t\t\t\t} else {","\t\t\t\t\tthis[dim] = outerLen;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// add in the padding and border","\t\t\t\tif (boxSizingProp && (boxSizingValue == 'padding-box' || boxSizingValue == 'content-box')) {","\t\t\t\t\touterLen += parseFloat($.curCSS(elem, 'padding-' + side[dim][0], true)) || 0 +","\t\t\t\t\t\t\t\t  parseFloat($.curCSS(elem, 'padding-' + side[dim][1], true)) || 0;","\t\t\t\t}","\t\t\t\tif (boxSizingProp && boxSizingValue == 'content-box') {","\t\t\t\t\touterLen += parseFloat($.curCSS(elem, 'border-' + side[dim][0] + '-width', true)) || 0 +","\t\t\t\t\t\t\t\t  parseFloat($.curCSS(elem, 'border-' + side[dim][1] + '-width', true)) || 0;","\t\t\t\t}","\t\t\t\t","\t\t\t\t// remember and return the outerHeight","\t\t\t\tthis[funcName] = outerLen;","\t\t\t\treturn outerLen;","\t\t\t}","\t\t\treturn this.$elem[funcName]();","\t\t}","\t});","\t","\t/**","\t * Determine the correct property for checking the box-sizing property","\t * @param void","\t * @return string","\t */","\tvar _boxSizingProperty = null;","\tfunction _findBoxSizingProperty () {","\t\tif (_boxSizingProperty) {","\t\t\treturn _boxSizingProperty;","\t\t} ","\t\t","\t\tvar property = {","\t\t\t\tboxSizing : 'box-sizing',","\t\t\t\tMozBoxSizing : '-moz-box-sizing',","\t\t\t\tWebkitBoxSizing : '-webkit-box-sizing',","\t\t\t\tOBoxSizing : '-o-box-sizing'","\t\t\t},","\t\t\telem = document.body;","\t\t","\t\tfor (var p in property) {","\t\t\tif (typeof elem.style[p] != 'undefined') {","\t\t\t\t_boxSizingProperty = property[p];","\t\t\t\treturn _boxSizingProperty;","\t\t\t}","\t\t}","\t\treturn null;","\t}","})(jQuery, this, this.document);",""],"id":1}]]},"timestamp":1456223097000}