{"filter":false,"title":"jquery.transform.2d.js","tooltip":"/client/js/jquery.transform.2d.js","ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":549,"column":0},"end":{"row":549,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"hash":"9a22143f1ffc46ae433906fd50ced75bdf4c8997","undoManager":{"mark":0,"position":0,"stack":[[{"start":{"row":0,"column":0},"end":{"row":549,"column":0},"action":"insert","lines":["/*"," * transform: A jQuery cssHooks adding cross-browser 2d transform capabilities to $.fn.css() and $.fn.animate()"," *"," * limitations:"," * - requires jQuery 1.4.3+"," * - Should you use the *translate* property, then your elements need to be absolutely positionned in a relatively positionned wrapper **or it will fail in IE678**."," * - transformOrigin is not accessible"," *"," * latest version and complete README available on Github:"," * https://github.com/louisremi/jquery.transform.js"," *"," * Copyright 2011 @louis_remi"," * Licensed under the MIT license."," *"," * This saved you an hour of work?"," * Send me music http://www.amazon.co.uk/wishlist/HNTU0468LQON"," *"," */","(function( $, window, document, Math, undefined ) {","","/*"," * Feature tests and global variables"," */","var div = document.createElement(\"div\"),","\tdivStyle = div.style,","\tsuffix = \"Transform\",","\ttestProperties = [","\t\t\"O\" + suffix,","\t\t\"ms\" + suffix,","\t\t\"Webkit\" + suffix,","\t\t\"Moz\" + suffix","\t],","\ti = testProperties.length,","\tsupportProperty,","\tsupportMatrixFilter,","\tsupportFloat32Array = \"Float32Array\" in window,","\tpropertyHook,","\tpropertyGet,","\trMatrix = /Matrix([^)]*)/,","\trAffine = /^\\s*matrix\\(\\s*1\\s*,\\s*0\\s*,\\s*0\\s*,\\s*1\\s*(?:,\\s*0(?:px)?\\s*){2}\\)\\s*$/,","\t_transform = \"transform\",","\t_transformOrigin = \"transformOrigin\",","\t_translate = \"translate\",","\t_rotate = \"rotate\",","\t_scale = \"scale\",","\t_skew = \"skew\",","\t_matrix = \"matrix\";","","// test different vendor prefixes of these properties","while ( i-- ) {","\tif ( testProperties[i] in divStyle ) {","\t\t$.support[_transform] = supportProperty = testProperties[i];","\t\t$.support[_transformOrigin] = supportProperty + \"Origin\";","\t\tcontinue;","\t}","}","// IE678 alternative","if ( !supportProperty ) {","\t$.support.matrixFilter = supportMatrixFilter = divStyle.filter === \"\";","}","","// px isn't the default unit of these properties","$.cssNumber[_transform] = $.cssNumber[_transformOrigin] = true;","","/*"," * fn.css() hooks"," */","if ( supportProperty && supportProperty != _transform ) {","\t// Modern browsers can use jQuery.cssProps as a basic hook","\t$.cssProps[_transform] = supportProperty;","\t$.cssProps[_transformOrigin] = supportProperty + \"Origin\";","","\t// Firefox needs a complete hook because it stuffs matrix with \"px\"","\tif ( supportProperty == \"Moz\" + suffix ) {","\t\tpropertyHook = {","\t\t\tget: function( elem, computed ) {","\t\t\t\treturn (computed ?","\t\t\t\t\t// remove \"px\" from the computed matrix","\t\t\t\t\t$.css( elem, supportProperty ).split(\"px\").join(\"\"):","\t\t\t\t\telem.style[supportProperty]","\t\t\t\t);","\t\t\t},","\t\t\tset: function( elem, value ) {","\t\t\t\t// add \"px\" to matrices","\t\t\t\telem.style[supportProperty] = /matrix\\([^)p]*\\)/.test(value) ?","\t\t\t\t\tvalue.replace(/matrix((?:[^,]*,){4})([^,]*),([^)]*)/, _matrix+\"$1$2px,$3px\"):","\t\t\t\t\tvalue;","\t\t\t}","\t\t};","\t/* Fix two jQuery bugs still present in 1.5.1","\t * - rupper is incompatible with IE9, see http://jqbug.com/8346","\t * - jQuery.css is not really jQuery.cssProps aware, see http://jqbug.com/8402","\t */","\t} else if ( /^1\\.[0-5](?:\\.|$)/.test($.fn.jquery) ) {","\t\tpropertyHook = {","\t\t\tget: function( elem, computed ) {","\t\t\t\treturn (computed ?","\t\t\t\t\t$.css( elem, supportProperty.replace(/^ms/, \"Ms\") ):","\t\t\t\t\telem.style[supportProperty]","\t\t\t\t);","\t\t\t}","\t\t};","\t}","\t/* TODO: leverage hardware acceleration of 3d transform in Webkit only","\telse if ( supportProperty == \"Webkit\" + suffix && support3dTransform ) {","\t\tpropertyHook = {","\t\t\tset: function( elem, value ) {","\t\t\t\telem.style[supportProperty] = ","\t\t\t\t\tvalue.replace();","\t\t\t}","\t\t}","\t}*/","","} else if ( supportMatrixFilter ) {","\tpropertyHook = {","\t\tget: function( elem, computed, asArray ) {","\t\t\tvar elemStyle = ( computed && elem.currentStyle ? elem.currentStyle : elem.style ),","\t\t\t\tmatrix, data;","","\t\t\tif ( elemStyle && rMatrix.test( elemStyle.filter ) ) {","\t\t\t\tmatrix = RegExp.$1.split(\",\");","\t\t\t\tmatrix = [","\t\t\t\t\tmatrix[0].split(\"=\")[1],","\t\t\t\t\tmatrix[2].split(\"=\")[1],","\t\t\t\t\tmatrix[1].split(\"=\")[1],","\t\t\t\t\tmatrix[3].split(\"=\")[1]","\t\t\t\t];","\t\t\t} else {","\t\t\t\tmatrix = [1,0,0,1];","\t\t\t}","","\t\t\tif ( ! $.cssHooks[_transformOrigin] ) {","\t\t\t\tmatrix[4] = elemStyle ? parseInt(elemStyle.left, 10) || 0 : 0;","\t\t\t\tmatrix[5] = elemStyle ? parseInt(elemStyle.top, 10) || 0 : 0;","","\t\t\t} else {","\t\t\t\tdata = $._data( elem, \"transformTranslate\", undefined );","\t\t\t\tmatrix[4] = data ? data[0] : 0;","\t\t\t\tmatrix[5] = data ? data[1] : 0;","\t\t\t}","","\t\t\treturn asArray ? matrix : _matrix+\"(\" + matrix + \")\";","\t\t},","\t\tset: function( elem, value, animate ) {","\t\t\tvar elemStyle = elem.style,","\t\t\t\tcurrentStyle,","\t\t\t\tMatrix,","\t\t\t\tfilter,","\t\t\t\tcenterOrigin;","","\t\t\tif ( !animate ) {","\t\t\t\telemStyle.zoom = 1;","\t\t\t}","","\t\t\tvalue = matrix(value);","","\t\t\t// rotate, scale and skew","\t\t\tMatrix = [","\t\t\t\t\"Matrix(\"+","\t\t\t\t\t\"M11=\"+value[0],","\t\t\t\t\t\"M12=\"+value[2],","\t\t\t\t\t\"M21=\"+value[1],","\t\t\t\t\t\"M22=\"+value[3],","\t\t\t\t\t\"SizingMethod='auto expand'\"","\t\t\t].join();","\t\t\tfilter = ( currentStyle = elem.currentStyle ) && currentStyle.filter || elemStyle.filter || \"\";","","\t\t\telemStyle.filter = rMatrix.test(filter) ?","\t\t\t\tfilter.replace(rMatrix, Matrix) :","\t\t\t\tfilter + \" progid:DXImageTransform.Microsoft.\" + Matrix + \")\";","","\t\t\tif ( ! $.cssHooks[_transformOrigin] ) {","","\t\t\t\t// center the transform origin, from pbakaus's Transformie http://github.com/pbakaus/transformie","\t\t\t\tif ( (centerOrigin = $.transform.centerOrigin) ) {","\t\t\t\t\telemStyle[centerOrigin == \"margin\" ? \"marginLeft\" : \"left\"] = -(elem.offsetWidth/2) + (elem.clientWidth/2) + \"px\";","\t\t\t\t\telemStyle[centerOrigin == \"margin\" ? \"marginTop\" : \"top\"] = -(elem.offsetHeight/2) + (elem.clientHeight/2) + \"px\";","\t\t\t\t}","","\t\t\t\t// translate","\t\t\t\t// We assume that the elements are absolute positionned inside a relative positionned wrapper","\t\t\t\telemStyle.left = value[4] + \"px\";","\t\t\t\telemStyle.top = value[5] + \"px\";","","\t\t\t} else {","\t\t\t\t$.cssHooks[_transformOrigin].set( elem, value );","\t\t\t}","\t\t}","\t};","}","// populate jQuery.cssHooks with the appropriate hook if necessary","if ( propertyHook ) {","\t$.cssHooks[_transform] = propertyHook;","}","// we need a unique setter for the animation logic","propertyGet = propertyHook && propertyHook.get || $.css;","","/*"," * fn.animate() hooks"," */","$.fx.step.transform = function( fx ) {","\tvar elem = fx.elem,","\t\tstart = fx.start,","\t\tend = fx.end,","\t\tpos = fx.pos,","\t\ttransform = \"\",","\t\tprecision = 1E5,","\t\ti, startVal, endVal, unit;","","\t// fx.end and fx.start need to be converted to interpolation lists","\tif ( !start || typeof start === \"string\" ) {","","\t\t// the following block can be commented out with jQuery 1.5.1+, see #7912","\t\tif ( !start ) {","\t\t\tstart = propertyGet( elem, supportProperty );","\t\t}","","\t\t// force layout only once per animation","\t\tif ( supportMatrixFilter ) {","\t\t\telem.style.zoom = 1;","\t\t}","","\t\t// replace \"+=\" in relative animations (-= is meaningless with transforms)","\t\tend = end.split(\"+=\").join(start);","","\t\t// parse both transform to generate interpolation list of same length","\t\treturn $.extend( fx, interpolationList( start, end ) );","\t}","","\ti = start.length;","","\t// interpolate functions of the list one by one","\twhile ( i-- ) {","\t\tstartVal = start[i];","\t\tendVal = end[i];","\t\tunit = +false;","","\t\tswitch ( startVal[0] ) {","","\t\t\tcase _translate:","\t\t\t\tunit = \"px\";","\t\t\tcase _scale:","\t\t\t\tunit || ( unit = \" \");","","\t\t\t\ttransform = startVal[0] + \"(\" +","\t\t\t\t\tMath.round( (startVal[1][0] + (endVal[1][0] - startVal[1][0]) * pos) * precision ) / precision + unit +\",\"+","\t\t\t\t\tMath.round( (startVal[1][1] + (endVal[1][1] - startVal[1][1]) * pos) * precision ) / precision + unit + \")\"+","\t\t\t\t\ttransform;","\t\t\t\tbreak;","","\t\t\tcase _skew + \"X\":","\t\t\tcase _skew + \"Y\":","\t\t\tcase _rotate:","\t\t\t\ttransform = startVal[0] + \"(\" +","\t\t\t\t\tMath.round( (startVal[1] + (endVal[1] - startVal[1]) * pos) * precision ) / precision +\"rad)\"+","\t\t\t\t\ttransform;","\t\t\t\tbreak;","\t\t}","\t}","","\tfx.origin && ( transform = fx.origin + transform );","","\tpropertyHook && propertyHook.set ?","\t\tpropertyHook.set( elem, transform, +true ):","\t\telem.style[supportProperty] = transform;","};","","/*"," * Utility functions"," */","","// turns a transform string into its \"matrix(A,B,C,D,X,Y)\" form (as an array, though)","function matrix( transform ) {","\ttransform = transform.split(\")\");","\tvar","\t\t\ttrim = $.trim","\t\t, i = -1","\t\t// last element of the array is an empty string, get rid of it","\t\t, l = transform.length -1","\t\t, split, prop, val","\t\t, prev = supportFloat32Array ? new Float32Array(6) : []","\t\t, curr = supportFloat32Array ? new Float32Array(6) : []","\t\t, rslt = supportFloat32Array ? new Float32Array(6) : [1,0,0,1,0,0]","\t\t;","","\tprev[0] = prev[3] = rslt[0] = rslt[3] = 1;","\tprev[1] = prev[2] = prev[4] = prev[5] = 0;","","\t// Loop through the transform properties, parse and multiply them","\twhile ( ++i < l ) {","\t\tsplit = transform[i].split(\"(\");","\t\tprop = trim(split[0]);","\t\tval = split[1];","\t\tcurr[0] = curr[3] = 1;","\t\tcurr[1] = curr[2] = curr[4] = curr[5] = 0;","","\t\tswitch (prop) {","\t\t\tcase _translate+\"X\":","\t\t\t\tcurr[4] = parseInt(val, 10);","\t\t\t\tbreak;","","\t\t\tcase _translate+\"Y\":","\t\t\t\tcurr[5] = parseInt(val, 10);","\t\t\t\tbreak;","","\t\t\tcase _translate:","\t\t\t\tval = val.split(\",\");","\t\t\t\tcurr[4] = parseInt(val[0], 10);","\t\t\t\tcurr[5] = parseInt(val[1] || 0, 10);","\t\t\t\tbreak;","","\t\t\tcase _rotate:","\t\t\t\tval = toRadian(val);","\t\t\t\tcurr[0] = Math.cos(val);","\t\t\t\tcurr[1] = Math.sin(val);","\t\t\t\tcurr[2] = -Math.sin(val);","\t\t\t\tcurr[3] = Math.cos(val);","\t\t\t\tbreak;","","\t\t\tcase _scale+\"X\":","\t\t\t\tcurr[0] = +val;","\t\t\t\tbreak;","","\t\t\tcase _scale+\"Y\":","\t\t\t\tcurr[3] = val;","\t\t\t\tbreak;","","\t\t\tcase _scale:","\t\t\t\tval = val.split(\",\");","\t\t\t\tcurr[0] = val[0];","\t\t\t\tcurr[3] = val.length>1 ? val[1] : val[0];","\t\t\t\tbreak;","","\t\t\tcase _skew+\"X\":","\t\t\t\tcurr[2] = Math.tan(toRadian(val));","\t\t\t\tbreak;","","\t\t\tcase _skew+\"Y\":","\t\t\t\tcurr[1] = Math.tan(toRadian(val));","\t\t\t\tbreak;","","\t\t\tcase _matrix:","\t\t\t\tval = val.split(\",\");","\t\t\t\tcurr[0] = val[0];","\t\t\t\tcurr[1] = val[1];","\t\t\t\tcurr[2] = val[2];","\t\t\t\tcurr[3] = val[3];","\t\t\t\tcurr[4] = parseInt(val[4], 10);","\t\t\t\tcurr[5] = parseInt(val[5], 10);","\t\t\t\tbreak;","\t\t}","","\t\t// Matrix product (array in column-major order)","\t\trslt[0] = prev[0] * curr[0] + prev[2] * curr[1];","\t\trslt[1] = prev[1] * curr[0] + prev[3] * curr[1];","\t\trslt[2] = prev[0] * curr[2] + prev[2] * curr[3];","\t\trslt[3] = prev[1] * curr[2] + prev[3] * curr[3];","\t\trslt[4] = prev[0] * curr[4] + prev[2] * curr[5] + prev[4];","\t\trslt[5] = prev[1] * curr[4] + prev[3] * curr[5] + prev[5];","","\t\tprev = [rslt[0],rslt[1],rslt[2],rslt[3],rslt[4],rslt[5]];","\t}","\treturn rslt;","}","","// turns a matrix into its rotate, scale and skew components","// algorithm from http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp","function unmatrix(matrix) {","\tvar","\t\t\tscaleX","\t\t, scaleY","\t\t, skew","\t\t, A = matrix[0]","\t\t, B = matrix[1]","\t\t, C = matrix[2]","\t\t, D = matrix[3]","\t\t;","","\t// Make sure matrix is not singular","\tif ( A * D - B * C ) {","\t\t// step (3)","\t\tscaleX = Math.sqrt( A * A + B * B );","\t\tA /= scaleX;","\t\tB /= scaleX;","\t\t// step (4)","\t\tskew = A * C + B * D;","\t\tC -= A * skew;","\t\tD -= B * skew;","\t\t// step (5)","\t\tscaleY = Math.sqrt( C * C + D * D );","\t\tC /= scaleY;","\t\tD /= scaleY;","\t\tskew /= scaleY;","\t\t// step (6)","\t\tif ( A * D < B * C ) {","\t\t\tA = -A;","\t\t\tB = -B;","\t\t\tskew = -skew;","\t\t\tscaleX = -scaleX;","\t\t}","","\t// matrix is singular and cannot be interpolated","\t} else {","\t\t// In this case the elem shouldn't be rendered, hence scale == 0","\t\tscaleX = scaleY = skew = 0;","\t}","","\t// The recomposition order is very important","\t// see http://hg.mozilla.org/mozilla-central/file/7cb3e9795d04/layout/style/nsStyleAnimation.cpp#l971","\treturn [","\t\t[_translate, [+matrix[4], +matrix[5]]],","\t\t[_rotate, Math.atan2(B, A)],","\t\t[_skew + \"X\", Math.atan(skew)],","\t\t[_scale, [scaleX, scaleY]]","\t];","}","","// build the list of transform functions to interpolate","// use the algorithm described at http://dev.w3.org/csswg/css3-2d-transforms/#animation","function interpolationList( start, end ) {","\tvar list = {","\t\t\tstart: [],","\t\t\tend: []","\t\t},","\t\ti = -1, l,","\t\tcurrStart, currEnd, currType;","","\t// get rid of affine transform matrix","\t( start == \"none\" || isAffine( start ) ) && ( start = \"\" );","\t( end == \"none\" || isAffine( end ) ) && ( end = \"\" );","","\t// if end starts with the current computed style, this is a relative animation","\t// store computed style as the origin, remove it from start and end","\tif ( start && end && !end.indexOf(\"matrix\") && toArray( start ).join() == toArray( end.split(\")\")[0] ).join() ) {","\t\tlist.origin = start;","\t\tstart = \"\";","\t\tend = end.slice( end.indexOf(\")\") +1 );","\t}","","\tif ( !start && !end ) { return; }","","\t// start or end are affine, or list of transform functions are identical","\t// => functions will be interpolated individually","\tif ( !start || !end || functionList(start) == functionList(end) ) {","","\t\tstart && ( start = start.split(\")\") ) && ( l = start.length );","\t\tend && ( end = end.split(\")\") ) && ( l = end.length );","","\t\twhile ( ++i < l-1 ) {","\t\t\tstart[i] && ( currStart = start[i].split(\"(\") );","\t\t\tend[i] && ( currEnd = end[i].split(\"(\") );","\t\t\tcurrType = $.trim( ( currStart || currEnd )[0] );","","\t\t\tappend( list.start, parseFunction( currType, currStart ? currStart[1] : 0 ) );","\t\t\tappend( list.end, parseFunction( currType, currEnd ? currEnd[1] : 0 ) );","\t\t}","","\t// otherwise, functions will be composed to a single matrix","\t} else {","\t\tlist.start = unmatrix(matrix(start));","\t\tlist.end = unmatrix(matrix(end))","\t}","","\treturn list;","}","","function parseFunction( type, value ) {","\tvar","\t\t// default value is 1 for scale, 0 otherwise","\t\tdefaultValue = +(!type.indexOf(_scale)),","\t\tscaleX,","\t\t// remove X/Y from scaleX/Y & translateX/Y, not from skew","\t\tcat = type.replace( /e[XY]/, \"e\" );","","\tswitch ( type ) {","\t\tcase _translate+\"Y\":","\t\tcase _scale+\"Y\":","","\t\t\tvalue = [","\t\t\t\tdefaultValue,","\t\t\t\tvalue ?","\t\t\t\t\tparseFloat( value ):","\t\t\t\t\tdefaultValue","\t\t\t];","\t\t\tbreak;","","\t\tcase _translate+\"X\":","\t\tcase _translate:","\t\tcase _scale+\"X\":","\t\t\tscaleX = 1;","\t\tcase _scale:","","\t\t\tvalue = value ?","\t\t\t\t( value = value.split(\",\") ) &&\t[","\t\t\t\t\tparseFloat( value[0] ),","\t\t\t\t\tparseFloat( value.length>1 ? value[1] : type == _scale ? scaleX || value[0] : defaultValue+\"\" )","\t\t\t\t]:","\t\t\t\t[defaultValue, defaultValue];","\t\t\tbreak;","","\t\tcase _skew+\"X\":","\t\tcase _skew+\"Y\":","\t\tcase _rotate:","\t\t\tvalue = value ? toRadian( value ) : 0;","\t\t\tbreak;","","\t\tcase _matrix:","\t\t\treturn unmatrix( value ? toArray(value) : [1,0,0,1,0,0] );","\t\t\tbreak;","\t}","","\treturn [[ cat, value ]];","}","","function isAffine( matrix ) {","\treturn rAffine.test(matrix);","}","","function functionList( transform ) {","\treturn transform.replace(/(?:\\([^)]*\\))|\\s/g, \"\");","}","","function append( arr1, arr2, value ) {","\twhile ( value = arr2.shift() ) {","\t\tarr1.push( value );","\t}","}","","// converts an angle string in any unit to a radian Float","function toRadian(value) {","\treturn ~value.indexOf(\"deg\") ?","\t\tparseInt(value,10) * (Math.PI * 2 / 360):","\t\t~value.indexOf(\"grad\") ?","\t\t\tparseInt(value,10) * (Math.PI/200):","\t\t\tparseFloat(value);","}","","// Converts \"matrix(A,B,C,D,X,Y)\" to [A,B,C,D,X,Y]","function toArray(matrix) {","\t// remove the unit of X and Y for Firefox","\tmatrix = /([^,]*),([^,]*),([^,]*),([^,]*),([^,p]*)(?:px)?,([^)p]*)(?:px)?/.exec(matrix);","\treturn [matrix[1], matrix[2], matrix[3], matrix[4], matrix[5], matrix[6]];","}","","$.transform = {","\tcenterOrigin: \"margin\"","};","","})( jQuery, window, document, Math );",""],"id":1}]]},"timestamp":1456210962000}